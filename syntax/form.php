<?php
/**
 * Bibdataform
 * 
 * Inserts a form which allows searching and filtering in a list
 * generated by a datatable (data plugin) or a datatemplatelist
 * (datatemplate plugin).
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author     Christoph Clausen <christoph.clausen@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();
require_once(DOKU_PLUGIN.'syntax.php');

/**
 * All DokuWiki plugins to extend the parser/rendering mechanism
 * need to inherit from this class
 */
class syntax_plugin_bibdata_form extends DokuWiki_Syntax_Plugin {

   /**
    * Get the type of syntax this plugin defines.
    *
    * @param none
    * @return String <tt>'substition'</tt> (i.e. 'substitution').
    * @public
    * @static
    */
    function getType(){
        return 'substition';
    }
	
    /**
     * What kind of syntax do we allow (optional)
     */
//    function getAllowedTypes() {
//        return array();
//    }
   
   /**
    * Define how this plugin is handled regarding paragraphs.
    *
    * <p>
    * This method is important for correct XHTML nesting. It returns
    * one of the following values:
    * </p>
    * <dl>
    * <dt>normal</dt><dd>The plugin can be used inside paragraphs.</dd>
    * <dt>block</dt><dd>Open paragraphs need to be closed before
    * plugin output.</dd>
    * <dt>stack</dt><dd>Special case: Plugin wraps other paragraphs.</dd>
    * </dl>
    * @param none
    * @return String <tt>'block'</tt>.
    * @public
    * @static
    */
    function getPType(){
        return 'block';
    }

   /**
    * Where to sort in?
    *
    * @param none
    * @return Integer <tt>6</tt>.
    * @public
    * @static
    */
    function getSort(){
        return 503;
    }


   /**
    * Connect lookup pattern to lexer.
    *
    * @param $aMode String The desired rendermode.
    * @return none
    * @public
    * @see render()
    */
    function connectTo($mode) {
      $this->Lexer->addSpecialPattern('<bibdataform>',$mode,'plugin_bibdata_form');
    }
	
   /**
    * Handler to prepare matched data for the rendering process.
    *
    * <p>
    * The <tt>$aState</tt> parameter gives the type of pattern
    * which triggered the call to this method:
    * </p>
    * <dl>
    * <dt>DOKU_LEXER_ENTER</dt>
    * <dd>a pattern set by <tt>addEntryPattern()</tt></dd>
    * <dt>DOKU_LEXER_MATCHED</dt>
    * <dd>a pattern set by <tt>addPattern()</tt></dd>
    * <dt>DOKU_LEXER_EXIT</dt>
    * <dd> a pattern set by <tt>addExitPattern()</tt></dd>
    * <dt>DOKU_LEXER_SPECIAL</dt>
    * <dd>a pattern set by <tt>addSpecialPattern()</tt></dd>
    * <dt>DOKU_LEXER_UNMATCHED</dt>
    * <dd>ordinary text encountered within the plugin's syntax mode
    * which doesn't match any pattern.</dd>
    * </dl>
    * @param $aMatch String The text matched by the patterns.
    * @param $aState Integer The lexer state for the match.
    * @param $aPos Integer The character position of the matched text.
    * @param $aHandler Object Reference to the Doku_Handler object.
    * @return Integer The current lexer state for the match.
    * @public
    * @see render()
    * @static
    */
    function handle($match, $state, $pos, &$handler){
		return array();
    }

   /**
    * Handle the actual output creation.
    *
    * <p>
    * The method checks for the given <tt>$aFormat</tt> and returns
    * <tt>FALSE</tt> when a format isn't supported. <tt>$aRenderer</tt>
    * contains a reference to the renderer object which is currently
    * handling the rendering. The contents of <tt>$aData</tt> is the
    * return value of the <tt>handle()</tt> method.
    * </p>
    * @param $aFormat String The output format to generate.
    * @param $aRenderer Object A reference to the renderer object.
    * @param $aData Array The data created by the <tt>handle()</tt>
    * method.
    * @return Boolean <tt>TRUE</tt> if rendered successfully, or
    * <tt>FALSE</tt> otherwise.
    * @public
    * @see handle()
    */
    function render($mode, &$R, $data) {
        if($mode == 'xhtml'){
        	$R->info['cache'] = false;
  			if (isset($_POST['bibdataform']) && checkSecurityToken()) {
	  			if(!isset($_REQUEST['dataflt'])){
		            $flt = array();
		        }elseif(!is_array($_REQUEST['dataflt'])){
		            $flt = (array) $_REQUEST['dataflt'];
		        }else{
		            $flt = $_REQUEST['dataflt'];
		        }
  			
  				if($_POST['field'] != 'Select field') {
	  				$new_flt = $_POST['field'] . '~*' . $_POST['contains'] . '*'; 
			        
			        if($_POST['reset'])
			        	$_REQUEST['dataflt'] = $new_flt;
			        else {
			        	$flt[] = $new_flt;
			        	$_REQUEST['dataflt'] = $flt;
			        }
  				} else {
  					if($_POST['reset'])
  						$_REQUEST['dataflt'] = array();
  				}
  			}
            
            $R->doc .= $this->_htmlform($data);
            $R->doc .= '<div id="__publist">Nothing.</div>';
            return true;
        }
        return false;
    }
    
	function _htmlform($data){
        global $ID;

        $form = new Doku_Form(array('class' => 'bibdataform_plugin'));
        $form->addHidden('bibdataform', $ID);
        if(array_key_exists('dataflt', $_REQUEST)) {
        	foreach($_REQUEST['dataflt'] as $flt)
        		$form->addHidden('dataflt[]', $flt);
        }
        $form->addElement(form_openfieldset(array('_legend' => 'Search/Filter', 'class' => 'bibdataform')));
        if($_POST['field'] == 'Select field' && !$_POST['reset']) {
        	$form->addElement('<span style="color:#F00">Please select a search field.</span>');
        }
        $form->addElement(form_makeMenuField('field', array('Select field', 'Title', 'Author', 'Journal', 'Year', 'Abstract'), '', '', '', 'cell menu'));
        $form->addElement(form_makeTextField('contains', '', '', '', 'cell text'));
        $form->addElement(form_checkboxField(array('_text' => 'Reset previous filters.', 'name' => 'reset','value' => '1', '_class' => 'row')));
        $form->addElement(form_makeButton('submit', '', 'Submit'));
        $form->endFieldset();
        
        return $form->getForm();
    }
}

//Setup VIM: ex: et ts=4 enc=utf-8 :
?>